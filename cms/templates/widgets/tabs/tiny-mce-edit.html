<%! from django.utils.translation import ugettext as _ %>
<%page args="tabName"/>
<div style="margin: -20px;">
  <textarea id="visual-${html_id}" class="tiny-mce">${data | h}</textarea>
</div>

<script type='text/javascript'>
    $(document).ready(function(){
      (function(){
        ##Only one inner editor in tabs is supported in front-end. It means that
        ##you should have only one CodeMirror among tabs, one Tiny MCE, etc.

        ## Init Tiny-mce editor
        var $el = $("#visual-${html_id}"),
            visualEditor;

        var setupTinyMCE = function (ed) {
          ed.addButton('wrapAsCode', {
            title : 'Code',
            image : '/static/images/ico-tinymce-code.png',
            onclick : function () {
              ed.formatter.toggle('code')
              ## Without this, the dirty flag does not get set unless the user also types in text.
              ## Visual Editor must be marked as dirty or else we won't populate the Advanced Editor from it.
              ed.isNotDirty = false;
            }
          });
         ed.onNodeChange.add(function(editor, command, e){
            command.setActive('wrapAsCode', e.nodeName == 'CODE')
         });
          visualEditor = ed;
          ## Save link to TinyMCE in data attribute TinyMCE for further using in
          ## TabsEditorDescriptor for save data
          $el.data('TinyMCE', visualEditor);
        };

        var focusVisualEditor = function (visualEditor){
          visualEditor.focus();
          ## Need to mark editor as not dirty both when it is initially created and when we  switch back to it.
          visualEditor.isNotDirty = true;
        };

        ##   This is a workaround for the fact that tinyMCE's baseURL property is not getting correctly set on AWS
        ##   instances (like sandbox). It is not necessary to explicitly set baseURL when running locally.
        tinyMCE.baseURL = '/static/js/vendor/tiny_mce';
        var tiny_mce_textarea = $el.tinymce({
          script_url : '/static/js/vendor/tiny_mce/tiny_mce.js',
          theme : "advanced",
          skin: 'studio',
          schema: "html5",
          ## Necessary to preserve relative URLs to our images.
          convert_urls : false,
          ## TODO: we should share this CSS with studio (and LMS)
          content_css : "/static/css/tiny-mce.css",
          formats : {
            ## Disable h4, h5, and h6 styles as we don't have CSS for them.
            h4: {},
            h5: {},
            h6: {},
            ## tinyMCE does block level for code by default
            code: {inline: 'code'}
          },
          ## Disable visual aid on borderless table.
          visual:false,
          ## We may want to add "styleselect" when we collect all styles used throughout the LMS
          theme_advanced_buttons1 : "formatselect,bold,italic,underline,|,bullist,numlist,outdent,indent,|,blockquote,wrapAsCode,|,link,unlink",
          theme_advanced_toolbar_location : "top",
          theme_advanced_toolbar_align : "left",
          theme_advanced_statusbar_location : "none",
          theme_advanced_resizing : true,
          theme_advanced_blockformats : "p,pre,h1,h2,h3",
          width: '100%',
          height: '400px',
          setup : setupTinyMCE,
          ## Cannot get access to tinyMCE Editor instance (for focusing) until after it is rendered.
          ## The tinyMCE callback passes in the editor as a paramter.
          init_instance_callback: focusVisualEditor
        });



        ## Callback that ensures data sync between tabs
        TabsEditorDescriptor.registerTabCallback('${html_id}', '${tabName}', function(previous_tab){

          var $codemirror = $("#advanced-${html_id}").data('CodeMirror');

          if ($codemirror){
            visualEditor.setContent($codemirror.getValue())
          }

          ## In order for isDirty() to return true ONLY if edits have been made after setting the text,
          ## both the startContent must be sync'ed up and the dirty flag set to false.
          visualEditor.startContent = visualEditor.getContent({format: "raw", no_events: 1});
          focusVisualEditor(visualEditor)
        })

         ## Save function - executes when pressing save - to get information from nested editor,

        ## should be set, as templates executes before tabs-aggregator coffee executes
        TabsEditorDescriptor['tabs_save_functions']['${html_id}'] = TabsEditorDescriptor['tabs_save_functions']['${html_id}']  || {}

        TabsEditorDescriptor['tabs_save_functions']['${html_id}']['${tabName}'] = function(){
          return function(){

            ## if visualEditor is edited and active
            if (visualEditor.isDirty()){
              return visualEditor.getContent({no_events: 1})
            }
            else {
              ## visualEditor is active, but not edits are in there.
              ## Still save occurs - beacuse "E-text latex" is rendered to xml and saved.
              ## Latex pastes data to Codemirror.
              ## So get data from there.
              var $codemirror = $("#advanced-${html_id}").data('CodeMirror');
              if ($codemirror){
                return $codemirror.getValue();
              }
              else {
                return null;
              }
            }
          }
        }();

      }());

    });
</script>
